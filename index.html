<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PV NETWORK</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: white;
            font-family: Helvetica, sans-serif;
        }
        .tile {
            position: absolute;
            cursor: grab;
            transition: opacity 0.2s;
            background-size: cover;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .tile span {
            display: none;
            font-size: 12px;
            font-weight: regular;
            color: black;
            background: rgba(255, 255, 255, 0.7);
            padding: 8px 16px;
            border-radius: 50px;
        }
        #tile1 { width: 262px; height: 147px; background-image: url('https://lh3.googleusercontent.com/d/13PeOgSdkZsJittnEKnShjZ6OaK0LK9NG'); }
        #tile2 { width: 450px; height: 291px; background-image: url('https://lh3.googleusercontent.com/d/1DV9-E6emc0Zvn8kkmiKJ_CX8LlZ4TN15'); }
        #tile3 { width: 167px; height: 250px; background-image: url('https://lh3.googleusercontent.com/d/16pyN0N02bhYOJJIGlBfBI7dDDfuaY2Mt'); }
        #tile4 { width: 236px; height: 177px; background-image: url('https://lh3.googleusercontent.com/d/1DZV8lstpNt1vjKdQS0fQgU5n3uF4DKKk'); }
        #tile5 { width: 150px; height: 150px; background-image: url('https://lh3.googleusercontent.com/d/1jZE2LEV3WCifZ8i-ffqIUa0vMVvTJxMf'); }
        #tile6 { width: 211px; height: 178px; background-image: url('https://lh3.googleusercontent.com/d/1_xAggQ95QUNL4gAg_G0Apkvzpzc-heVr'); }
        #tile7 { width: 205px; height: 295px; background-image: url('https://lh3.googleusercontent.com/d/1fhhRGuuPbxHo74pfiZ2YRGuzg2GefzCV'); }
    </style>
</head>
<body>
    <div id="tile1" class="tile"><span>STP Inventory of Public Water, Ahmedabad, Gujarat – Butler Traveling Fellowship, 2023</span></div>
    <div id="tile2" class="tile"><span>COW Urban Bovine Reconvalescene Center, Ahmedabad, Gujarat – Princeton Post-Pro Thesis</span></div>
    <div id="tile3" class="tile"><span>HOLY COW, STRAY COW ! Exhibition, Princeton SoA and Cheryl Hazan Gallery, Tribeca, NYC, March 2024</span></div>
    <div id="tile4" class="tile"><span>OAS Oase Forckenbeckstrasse Wastewater Treatment House, Berlin, Germany - M.A. Thesis, UdK-Berlin</span></div>
    <div id="tile5" class="tile"><span>MOA Mill Owners' Association Building LiDAR Scanning, Ahmedabad, Gujarat - CEPT University CHC</span></div>
    <div id="tile6" class="tile"><span>DEM Robotic Brickwork with Demolition Rubble, Princeton SoA and ARG (Adel Research Group)</span></div>
    <div id="tile7" class="tile"><span>OAS Oase Forckenbeckstrasse Wastewater Treatment House, Berlin, Germany - M.A. Thesis, UdK-Berlin</span></div>
    
    <script>


        class MovingTile {
            constructor(element, tiles) {
                this.element = element;
                this.dx = (Math.random() - 0.5) * 2;
                this.dy = (Math.random() - 0.5) * 2;
                this.moving = true;
                this.dragging = false;
                this.immovable = false; // New flag to track immovable tiles
                this.initPosition(tiles);
                this.move();
                this.addEventListeners();
            }
            
            initPosition(tiles) {
                let overlapping;
                do {
                    overlapping = false;
                    this.element.style.left = Math.random() * (window.innerWidth - this.element.clientWidth) + 'px';
                    this.element.style.top = Math.random() * (window.innerHeight - this.element.clientHeight) + 'px';
                    let rectA = this.element.getBoundingClientRect();
                    for (let tile of tiles) {
                        if (tile.element !== this.element) {
                            let rectB = tile.element.getBoundingClientRect();
                            if (
                                rectA.left < rectB.right &&
                                rectA.right > rectB.left &&
                                rectA.top < rectB.bottom &&
                                rectA.bottom > rectB.top
                            ) {
                                overlapping = true;
                                break;
                            }
                        }
                    }
                } while (overlapping);
            }
            
            move() {
                if (!this.moving || this.dragging || this.immovable) return;
                let rect = this.element.getBoundingClientRect();
                if (rect.left + this.dx < 0 || rect.right + this.dx > window.innerWidth) {
                    this.dx = -this.dx;
                }
                if (rect.top + this.dy < 0 || rect.bottom + this.dy > window.innerHeight) {
                    this.dy = -this.dy;
                }
                this.element.style.left = rect.left + this.dx + 'px';
                this.element.style.top = rect.top + this.dy + 'px';
                requestAnimationFrame(() => this.move());
            }
            
            addEventListeners() {
                this.element.addEventListener('click', () => {
                    this.immovable = !this.immovable;
                    this.moving = !this.moving;
                    this.element.style.opacity = this.immovable ? '0.5' : '1';
                    let text = this.element.querySelector('span');
                    text.style.display = this.immovable ? 'block' : 'none';
                    if (!this.immovable) this.move();
                });
                
                this.element.addEventListener('mousedown', (e) => {
                    this.dragging = true;
                    let shiftX = e.clientX - this.element.getBoundingClientRect().left;
                    let shiftY = e.clientY - this.element.getBoundingClientRect().top;
                    
                    const onMouseMove = (event) => {
                        this.element.style.left = event.clientX - shiftX + 'px';
                        this.element.style.top = event.clientY - shiftY + 'px';
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    
                    document.addEventListener('mouseup', () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        this.dragging = false;
                        if (this.moving) this.move();
                    }, { once: true });
                });
            }
        }
        
        function checkCollision(tileA, tileB) {
            if (tileA.immovable && tileB.immovable) return;
            
            let rectA = tileA.element.getBoundingClientRect();
            let rectB = tileB.element.getBoundingClientRect();
            
            if (
                rectA.left < rectB.right &&
                rectA.right > rectB.left &&
                rectA.top < rectB.bottom &&
                rectA.bottom > rectB.top
            ) {
                if (tileA.immovable) {
                    tileB.dx = -tileB.dx;
                    tileB.dy = -tileB.dy;
                } else if (tileB.immovable) {
                    tileA.dx = -tileA.dx;
                    tileA.dy = -tileA.dy;
                } else {
                    let tempDx = tileA.dx;
                    let tempDy = tileA.dy;
                    tileA.dx = tileB.dx;
                    tileA.dy = tileB.dy;
                    tileB.dx = tempDx;
                    tileB.dy = tempDy;
                }
            }
        }
        
        let tiles = [];
        tiles.push(new MovingTile(document.getElementById('tile1'), tiles));
        tiles.push(new MovingTile(document.getElementById('tile2'), tiles));
        tiles.push(new MovingTile(document.getElementById('tile3'), tiles));
        tiles.push(new MovingTile(document.getElementById('tile4'), tiles));
        tiles.push(new MovingTile(document.getElementById('tile5'), tiles));
        tiles.push(new MovingTile(document.getElementById('tile6'), tiles));
        tiles.push(new MovingTile(document.getElementById('tile7'), tiles));
        
        function collisionLoop() {
            for (let i = 0; i < tiles.length; i++) {
                for (let j = i + 1; j < tiles.length; j++) {
                    checkCollision(tiles[i], tiles[j]);
                }
            }
            requestAnimationFrame(collisionLoop);
        }
        collisionLoop();
        
        
    </script>
</body>
</html>
